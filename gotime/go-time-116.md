**Jon Calhoun:** Hello, everybody! Welcome to Go Time. Today we are joined with guest Andrew Williams. Wanna say hi, Andy?

**Andy Williams:** Hi, everybody. Thanks very much for inviting me along. It&#39;s really cool to be part of the chat.

**Jon Calhoun:** And then we have one of our hosts, Johnny Boursiquot...

**Johnny Boursiquot:** Hello, everybody. Good to be back.

**Jon Calhoun:** And myself, Jon Calhoun. Today we&#39;re gonna be talking about unusual uses for Go; just the weird ways developers are using Go. Maybe not weird, but just not quite the normal ones.

First, we just wanna establish what are some of the more common use cases of Go, and then we&#39;re gonna jump into what we&#39;d consider anything that sort of falls outside of that, is what we&#39;d say is slightly  unusual. That isn&#39;t to say that all of these are unusual. Some of them are more common than others, so you&#39;ll see that going in all different directions... And we&#39;re not trying to encourage anybody to not use go for any specific reasons; this is more of just exploring some different ways you might use it, that you might not have traditionally heard about.

Who wants to take the common use cases? What do you think those are?

**Johnny Boursiquot:** I can take a stab... Do you mind if I take a first stab, Andy?

**Andy Williams:** Yeah, on you go.

**Johnny Boursiquot:** Okay. So my own personal experience is that when I first heard of Go, it was all about back-end, systems-level kind of work, queueing technologies, databases, that kind of thing. High throughput, networked applications and services; what was being called at the time lower-level kind of back-end things, as opposed to your traditional web developer framework stacks we were familiar with. And really, that&#39;s been fairly consistent, up until about, I&#39;d say, three(ish) years ago. Then I saw an explosion of all kinds of different uses of Go. But yeah, we&#39;re gonna get into that... But that&#39;s my personal experience of what the common uses of Go have been for me until a few years ago.

**Andy Williams:** Yeah, I think that sounds about right for me as well. I&#39;ve only really been in the community for not even two years actually, so after all of these new and exciting areas started opening up... But the common use cases still seem to be focused around web servers, back-end systems, like you say; that&#39;s where the examples are. And often, if you ask somebody &quot;What&#39;s this language for?&quot;, they&#39;re pretty much gonna say &quot;What it was designed for.&quot; I think, like you said, that&#39;s solidly where it started.

**Jon Calhoun:** \{04:00\} Yeah, I&#39;d say my experience has been pretty similar. I&#39;ve definitely seen -- even on the web side of it; you see it a lot more in APIs and things that are returning JSON than with the -- like, you don&#39;t see the templating library being used quite as often to generate HTML. A lot of times when people think about web frameworks, they think about Rails, or something else... And that stuff has started to exist in Go, but it just wasn&#39;t nearly as common until more recently, as tools have started to emerge.

Okay, let me jump to the next question... Before we deep-dive into any specific areas, what is the strangest thing you&#39;ve seen Go used for?

**Andy Williams:** Wow... [laughs]

**Jon Calhoun:** Am I gonna throw you both off with that one?

**Andy Williams:** I mean, I&#39;m biased working so much in the GUI space; I&#39;ve seen some pretty crazy things done there, and there are some ideas around running user interfaces using native, that&#39;s then rendered through the web browser instead of using the web technologies. That feels pretty whacky to me. Interesting area, some cool applications, but not my first choice for how to build something.

**Johnny Boursiquot:** To me JavScript is  a weird one to have in Go. Specifically, I&#39;m thinking of projects like GopherJS, Vecty... There&#39;s some we&#39;ve got listed here, goplay.space - I&#39;m not sure what that&#39;s about... That&#39;s kind of odd. I don&#39;t wanna sound like I&#39;m anti JavScript in Go, but typically the way I see it is that if I need to do JavScript, I&#39;ll just go do JavScript. I wouldn&#39;t try to bring it in into my Go world. I have this odd desire to use the right tool for the job, and to me, trying to force that in -- I mean, I&#39;m sure it has its use cases, but for me personally, I haven&#39;t come across one where I really am like &quot;Well, you know what - yeah, let me do some JavScript through Go.&quot; It just never felt right to me.

**Jon Calhoun:** I think the JavScript one is the same for me, but mostly just because every time I&#39;ve looked at it and been like &quot;You know, I wanna try this thing. I wanna see what it&#39;s like&quot;, and then I look at it and I just think &quot;I almost feel like I need to know JavScript&quot;, and then  I need to know the Go version on top of it. So I&#39;m like, if I&#39;ve already learned JavScript at this point, I&#39;m not -- like, there&#39;s probably some benefits in different things... And that&#39;s not to say that it&#39;s not a cool project. I definitely like that people are experimenting and trying different stuff. I love that. It&#39;s just, I see it and I&#39;m like &quot;I cannot see me using this in a production environment, or trying to sell it to a manager.&quot; I don&#39;t know how I&#39;d make that sale.

So if somebody has actually made that sale, please let me know how you did it, because that&#39;s definitely an interesting one to pull off.

**Johnny Boursiquot:** It&#39;s a super-power. [laughs]

**Jon Calhoun:** Yeah... When you see those -- goplay.space is an example of something built with Vecty and GopherJS, and it&#39;s really cool, but I just sometimes wonder if you might be better off just finding somebody who knows the JavScript stuff really well, and just doing it that way... But it&#39;s hard to say. It is cool that people are doing it. But on the other side, the Web Assembly stuff I think has a lot of potential to be really cool in the future... And I&#39;m guessing things like GopherJS sort of helped pave the way for that, so I&#39;m like &quot;Alright, if it&#39;s helped me do that, that&#39;s pretty awesome, too.&quot;

**Johnny Boursiquot:** I&#39;m curious what the impetus is for doing these other things through Go. I imagine if you&#39;re really passionate about Go and you wanna use Go for all the things, maybe you can generate your JavScript from Go, and that&#39;s fine... Again, I see these things as more of being sort of nice, fun thought experiments, and nice projects that are pushing the boundaries of what&#39;s possible, and I think you do need these kinds of projects in any ecosystem, to sort of show &quot;Hey, let&#39;s think outside of the box that was defined for the language from day one&quot; kind of thing. I think those definitely have a place in the community, and they will always play a role...

\{07:57\} But to your point, if I&#39;m trying to build production-grade applications -- not to say that those projects can&#39;t produce production-grade applications, it&#39;s just I&#39;d have a hard time selling not doing JavScript in JavScript, or in a framework that is tailored for doing, say, graphical user interfaces or web interfaces, or even mobile interfaces with JavScript tooling. Trying to do that through Go - I&#39;d have a hard time selling that.

**Jon Calhoun:** Yeah. So it sounds like what we need to do is get somebody who&#39;s an expert in these areas and have them come on and change our mind, which would be pretty awesome.

**Johnny Boursiquot:** Yeah, I don&#39;t know. Do you think we can find one of those?

**Jon Calhoun:** We can look, we&#39;ll see. So we have Andrew here with us, and Andrew has a little bit more experience in what I&#39;d consider more the native graphical user interface area. For those of you who are not familiar with Andrew, he created - or helped create; I&#39;m not sure how that started - [Fyne](https://github.com/fyne-io/fyne), which is something that allows you to sort of build native graphical user interfaces (GUIs). So I guess the first question I wanna ask is &quot;Why don&#39;t we see more people doing graphical user interface type stuff in Go or in some of these languages?&quot; What makes it challenging? Because truly, people want to build these applications that work natively on any OS.

**Andy Williams:** Yeah, it&#39;s actually a bit of a mystery to me, honestly. When I was first thinking about how might you reimagine building graphical applications, which is kind of where Fyne came from, I looked at Go as a language and compared it with a few others and it just seemed like such a great fit, with the concurrency, memory management, and just the language semantics seemed to fit really well.

Partly, I think maybe there&#39;s not much going on in this space because that&#39;s not what people originally expected that the language would be useful for, so it&#39;s kind of a few years behind that opportunity, because it was particularly not worked on for a long time... But like Johnny said, it&#39;s been expanding over the last few years into lots of different areas, and people are starting to think outside of that area, so the graphical toolkits along with other things are coming along now... And you probably look at the Awesome Go list and see like 25 different toolkits, all trying to do something with graphical user interfaces in Go, and maybe half of those are on the embedded website, and the others would be to some flavor of native. That said, it is a really hard thing to do well, and if I tell somebody &quot;Oh yeah, we&#39;re building a new graphical interface toolkit from scratch&quot;, they just look at you and go &quot;Why? That&#39;s so much work... Surely, the ones that exist are good enough.&quot; So it is, I think, one of those challenges that people just go &quot;What&#39;s the point...?&quot;

**Jon Calhoun:** I know one of the big issues I see -- because people have been trying to make this cross-platform GUI-type thing for a while... You see React Native, and you see a bunch of others out there, and even on mobile, there were people who would be like &quot;Okay, come learn our thing and you can develop for both iOS and Android at the same time&quot;, which was always a big challenge... So I guess the first question is &quot;Do you think it&#39;s really possible to make good user interfaces that are cross-platform one time, or are we stuck just building it for each different operating system separately, because they all expect different stuff?&quot;

**Andy Williams:** Well, I absolutely think that it can be done. That is the purpose behind the project, to show that one of these considered impossible tasks actually just hadn&#39;t been tackled with the latest toolset, a language that supports these ideas. And if I didn&#39;t think it was possible, I&#39;d be doing something else with my time, for sure... So I think it&#39;s a question of trying to figure out &quot;How do you apply current technologies on top of all of the learning that we&#39;ve had over the last 20-30 years of building graphical interfaces and the toolkits that support them, and bring all of that together with a bit of fresh thinking?&quot;

\{11:59\} One of the things that really drove me initially was when the smartphone apps were really taking off and we saw what good usability could really look like... And then people looked at desktop and just went, &quot;Oh, these two are incompatible.&quot; Well, you know, maybe that&#39;s because actually we needed to take the opportunity to reimagine it and see how this could work across all platforms with a fresh look, and can we apply the design learnings, the usability, and take those concepts onto both desktop, but also the cross-platform with one codebase concept. I think there&#39;s a lot of space there to really come at this with a fresh angle, and that&#39;s what we&#39;re trying to do.

**Johnny Boursiquot:** There&#39;s always a trade-off. If you&#39;re trying to create something that&#39;s cross-platform, in some environments you might say &quot;Well, for the Mac environment - we can take advantage of certain things here, but for a Windows environment we can&#39;t take advantage of the same things; we have to sort of give up some things here in order to get that...&quot; So where are the trade-offs that you&#39;re making? Are you hiding those from the developer, from having to create sort of specific OS-based APIs and things for allowing a developer to do what they wanna do with the project?

**Andy Williams:** Yeah, absolutely. I guess there&#39;s definitely trade-offs in anything that you&#39;re trying to do cross-platform, although as the Go team have showed us, you can actually find clever ways to work around most of these and still have an elegant API at the end of the day. It probably would be worth looking at what native means, because there&#39;s a lot of different toolkits that are trying to be native and they can take different approaches. The [andlabs UI project](https://github.com/andlabs/ui), which is doing a really fantastic job of abstracting a standard API across system standard components so that you build an application with one codebase, and when you run it, it looks exactly like any other application on the system it&#39;s running on...

So the trade-off that they&#39;re gonna be taking on board is, I guess, the lowest common denominator to element, although they&#39;re managing to build more complex components off the standard items available... So Fyne&#39;s in a place where we thought &quot;Actually, let&#39;s have a standard user interface across all of these systems.&quot; So the trade-off there is probably the immediate recognition that a user might expect when they&#39;re loading a new application. We&#39;re presenting them something that is a little bit different. We&#39;re going for consistency across the platforms, as opposed to specifically consistency with the current system, which is a potentially courageous, but design choice that we made... So there&#39;s a bit of trade-off there with user familiarity.

The one that  we&#39;re looking at at the moment is around system dialogs. If you&#39;re running on, for example, the Apple desktop, there&#39;s a lot of functionality there (the iCloud document store etc.) that if you&#39;re saving a file, you would expect to have it presented to you... So we&#39;re needing to look at a system-by-system basis, how exactly that integration might work, so that people can get access to the files that they would expect on their system without a huge variance in the capability of the software running on different platforms. There&#39;s all sorts of ways that it has to vary across systems, but that&#39;s the one that&#39;s certainly on our mind at the moment.

**Jon Calhoun:** When you said &quot;The Go team showed us that we can actually use some clever things to get around the differences between the operating systems&quot;, just for anybody who&#39;s not familiar, I&#39;m assuming you&#39;re referring to having build tags and having specific Go files that compile depending on the language you&#39;re building for?

**Andy Williams:** Absolutely, that&#39;s a big part of it, but I guess I was more thinking that from the language and a standard library level you really don&#39;t need to worry about it at all, for the most part. If you&#39;re reaching for a build tag, you&#39;re probably wanting to do something specific for a certain platform when you&#39;re making that choice to break away from the guaranteed consistency across systems... And that is certainly a challenge when you start working in the graphical world, where those guarantees don&#39;t necessarily go away completely, but they certainly introduce a lot more challenges... And how you manage to have an API that is as easy to use as the standard Go library is, whilst dealing with these more system-specific concepts is a challenge, as well.

**Jon Calhoun:** \{16:17\} Yeah, so what I meant initially was that you can have multiple Go files, and  each one, depending on the language you&#39;re building for, is the one that&#39;s used... But the actual API that people are calling is the same functions, and they&#39;re generally expected to do the same thing, it&#39;s just how they do it might be a little bit different.

**Andy Williams:** Oh yeah, absolutely.

**Jon Calhoun:** But then the flip side to that is you kind of get lured into this almost wanting to have two things act in different ways, and you don&#39;t want developers to call a function and have to mentally think &quot;If I call this function and I&#39;m running on Mac, it&#39;s gonna do this thing. But if it&#39;s on Windows, it&#39;s gonna do something similar, but not quite the same... My code needs to adapt for both of those&quot;, which would be very challenging, especially -- like you said, in the GUI world, everything from alerts and notifications and just permissions... There&#39;s just so many different things that are really challenging to pull off, because that&#39;s where the differences in the operating systems really start to stick out.

**Andy Williams:** For sure, yeah. I think if anybody&#39;s ever trying to design an API that&#39;s gonna be consumed outside of your team at work, it&#39;s important to consider the path of least surprise for any developer that&#39;s gonna be using the API... And if you do want to put platform specifics in there, the outcome should really be entirely consistent, irrespective of the specifics that are happening behind the scenes... So there may be a significant difference to how things are functioning, but really the end result should be consistent. Notifications is a really interesting example there, but there&#39;s probably a hugely long list of those sorts of system items that are going to be challenged to do consistently across systems... But from the developer&#39;s point of view - yeah, they call a function, and a thing happens; the documentation, whether it&#39;s GoDoc or something more elaborate, is going to describe the functionality, not the platform-specific item, and I think that&#39;s important.

**Break:** \{18:09\}

**Jon Calhoun:** So you&#39;re working on Fyne, which does (I believe) mobile and desktop... Is that correct?

**Andy Williams:** It was desktop initially, and just in December we added mobile, so that&#39;s iOS, Android, and also a Raspberry Pi fitted in there, because it&#39;s running the same chipsets for the graphics output as the mobile devices are, so... It&#39;s not really mobile, but it was a nice added bonus at the same time.

**Jon Calhoun:** So when you&#39;re thinking about that, do you think about those -- like, when you&#39;re exposing an API, do you guys feel that that API should be the same for mobile and desktop, or is this something where you&#39;ve actually drawn a line and said &quot;One&#39;s different enough from the other that we can&#39;t just make it universal&quot;?

**Andy Williams:** \{20:10\} No, absolutely... These APIs that we&#39;re building have to be consistent completely. We&#39;re following Go&#39;s design principles on that, and everything that we do is idiomatic, or aiming to be idiomatic to the language, and consistent APIs is really important there. So if somebody&#39;s rating an application with Fyne, then they know that it&#39;s going to work across all of these different devices in the same way.

That said, there are sometimes differences between devices that you want to enable that aren&#39;t generic. The one that springs to mind right now is a virtual keyboard. That&#39;s not typically available on a desktop platform, so there are some APIs that are device-specific, and you can use appropriate calls to say &quot;You know what, if I&#39;m running in this environment, then take this action.&quot; So that&#39;s available if people want to customize their systems to the device it&#39;s running on, but it&#39;s not really encouraged, because we want to make as much of this completely transparent as possible.

**Jon Calhoun:** I know historically one of the big downsides to using something that does the GUIs across platforms tends to be performance, but a lot of times I think that&#39;s showing up in JavScript worlds, where everything&#39;s running through JavScript, rather than running in something that was actually compiled... So do you think using Go actually helps prevent that issue and keeps it snappy?

**Andy Williams:** Yes, absolutely. The performance that we&#39;ve experienced has been really phenomenal, actually. You&#39;re quite right, a lot of the technologies that try to tackle the cross-platform do suffer in some of their choices, and performances  can be challenging to keep up there... But when the Go code is compiled down to the machine, apart from some implementation details that we might have, it&#39;s gonna be running at the same speed as the native code as if you&#39;d been building with the toolkits that the platform was designed with... And partly because the graphics drivers that we have implemented are going straight down to the same hardware acceleration that the Swift or Java codes would be using as well.

**Jon Calhoun:** So I guess I find that interesting, because if you&#39;re getting down to that level, I know one of the common concerns that I hear people talk about - and this isn&#39;t specific to GUIs, but I talk to people in the system administration space and stuff like that, and they always make the argument that like -- say I&#39;m a Mac sys admin; they say that eventually I need to get into Swift to touch the lower-level things that I need to touch. I guess, do you ever run into cases where that&#39;s the case, where you really need to touch OS-specific APIs? Because that&#39;s one of the issues...

Or I guess a better way of putting this is that it seems like to write for Mac, you need to know Swift; to write for Windows, you need to know one of those .NET languages that actually can interact with the things they want you to sort of restrict... And it seems like they don&#39;t care as much about supporting other languages with those really specifics... So has that been a challenge, or is that something -- you&#39;re just not doing those things?

**Andy Williams:** It really is a challenge, yeah. Absolutely. There&#39;s certain things that there&#39;s just no way to address using a language that&#39;s not what was intended... And it&#39;s something that occupies my mind when we&#39;re working to do new capabilities on systems. But our best efforts are to hide all of that complexity from anybody that would be building their application with our APIs... So the project exposes a pure Go API, which is great for everybody who&#39;s working on it, and it makes a lot of sense in all the standard tools... But if you were to go and look at our source code, then you would find Java, and Objective-C, and some C... It&#39;s all brought together under the hood, depending on the target build system. And there&#39;s a couple of tricks in there to make sure that you don&#39;t have to have all of those variants installed all of the time just for a build to work. This is largely gonna work out of the box if you have Go and a C compiler.

\{24:15\} So there&#39;s a lot of complexity under the hood... But it means that we&#39;re able to hook into the platform-specific APIs, the types of things that are only available on an Android device if you&#39;re accessing the Java APIs, or that might only be exposed through Objective-C on an Apple computer... But we want to make sure that that is never anything that you would need to think about if you were building on top of our system.

There&#39;s obviously going to be areas where we haven&#39;t completely added all the support that we need to, but we&#39;re working on it over time, and if people find an area that they&#39;re having to reach out to some other language for, then we&#39;d encourage them to open a ticket and help us work that support into the main project.

**Jon Calhoun:** So you say that you build with Java and seeing these things... I guess can you talk a little bit more about that? Are you using just C bindings and connecting to things that are gonna be on every system? What does that look like? Are you talking like OpenGL, or is it something else?

**Andy Williams:** Yeah... So it is pretty much through [cgo](https://golang.org/cmd/cgo/) like you say and the main dependency issue is talking to OpenGL, which gives us access to the graphic subsystems. In fact, that is the only dependency for this on most systems. On desktop we don&#39;t need to do any clever things, for the most part... And some Apple APIs that might be required are actually accessible by C, or Objective-C that it compiles down to using the standard toolchain, so it&#39;s not really too much of a problem. When you&#39;re building for mobile, this becomes a lot more challenging, but the Go mobile team have done a fantastic job of actually solving a lot of the challenges there for us, and through extending that project we&#39;ve managed to add that support.

I think the craziest thing that I saw in terms of making that work was that the Android target has some Java code in it that&#39;s pre-compiled into a text binary that&#39;s then bundled into the Go source code as a data asset, and then that&#39;s extracted as part of the build process to give you your bootstrap into the Go runtime. Now, I would rather hope that nobody using this would ever know that that existed under there... But if you wanted to delve into &quot;How can I improve this for Android specifically?&quot;, you&#39;re gonna find some really weird stuff.

**Jon Calhoun:** Yeah, I could imagine that being confusing, at the very least, when you&#39;re getting started... So the Go mobile project is what was helping you bootstrap into that... Was there anything that you&#39;ve found - open source or otherwise - that helped you get started with the overall project, or getting into OpenGL and that sort of space?

**Andy Williams:** Actually, the graphics is a complicated area, I guess... And it&#39;s very low-level, so the code reuse between projects is not exactly shining in that area. Really, I guess I was just basing on experience I had with previous projects as much as anything. I can&#39;t think of anything in particular that we really called on... Although I suppose initially the project did use the render pipeline from the EFL toolchain (that&#39;s the Enlightenment Project). That gave us some abstraction for the graphics driver. But in the end, we realized that to really build an idiomatic API top to bottom, we couldn&#39;t depend on an abstraction built in another language. It just didn&#39;t really speak the right language for us, and we were working a lot to work around the way it functioned, and we had duplicated code in there, and thought &quot;Actually, this doesn&#39;t make sense&quot;, so we took it out and implemented it from scratch, right the way down to the hardware.

**Jon Calhoun:** I mean, it&#39;s probably even more pronounced in your space, but I think in a lot of spaces you&#39;ll see that sort of difference, as to whether or not they started with the end user -- like, they&#39;re designing the API for end users, versus starting with something they had to work with to touch the back-end, and then working their way towards the end user... Because an API that&#39;s designed for end users will look very clearly like they designed this for me to use it.

\{28:22\} And then there&#39;s other cases where you get an API where it&#39;s really confusing, or everything&#39;s just scattered all over... I&#39;m trying to think of an example, but I can&#39;t off the top of my head. But I know I&#39;ve definitely seen even just Web APIs, where you can tell the Web API is based off of the data models that they&#39;re storing things in, rather than what end users are actually gonna wanna use, and as a result, it just ends up looking not very user-friendly, because they didn&#39;t think &quot;What is a user actually going to want here, versus what&#39;s easiest for us to give to them?&quot;

**Andy Williams:** Absolutely, yeah. And sometimes you want a design that&#39;s  close to the hardware, or close to the data model, and there are projects out there that would use that design on purpose... But I think really for our project we&#39;re trying to make this as easy to use as possible, even for a first-time graphical app developer; so it needs to be built with them in mind, with as few lines of code as possible, very clear intent in every single line of code, so that nothing is excess, nothing is confusing.

But there are different approaches for a lot of graphic libraries that expose exactly how  a graphics pipeline works, and you&#39;re feeding instructions into that pipeline. If you were building a game engine, that would be really important for you. But we&#39;re pretty sure that really enabling folks to quickly build applications that are user-friendly is what&#39;s most significantly lacking at the moment, and especially cross-platform. There&#39;s just not really anything there if you don&#39;t want to worry about the fun of web technologies inside your seemingly native applications.

**Jon Calhoun:** Yeah, that makes sense. And I guess one way I view it is -- you mentioned game engines, and I think there are some people who wanna definitely access the low-level stuff, but for the most part, at least when I&#39;m watching people make games, it seems like a lot of them want to use engines of some sort; they wanna use Unreal Engine, or some engine of some sort that abstracts some of that away for them, so that they can kind of speak in a not quite system-level language; they can actually start talking about things in a way that makes more sense to them.

So I get what you mean, there&#39;s definitely some people who need that low-level, but I think there&#39;s a lot more people that tend to talk at that higher-level, a little bit easier to understand language.

**Andy Williams:** Yeah, absolutely. I mean, every API is still built with a design in mind, and I think you&#39;re right, it&#39;s important to know who you&#39;re designing for when you set out, because changing that after the fact is gonna be really difficult, and probably make a rather confusing product at the end of the day.

**Jon Calhoun:** Okay, so we talked a little bit about gaming stuff... Do you think a lot of this is why the gaming space is just not that common in Go as well? Is it basically the same type of challenges getting that stuff rendering, or do you think there&#39;s different challenges there?

**Andy Williams:** Well, there&#39;s a lot of projects out there that can actually get something rendering to the screen; I&#39;m not entirely sure that that&#39;s a challenge now. Maybe people are still cautious because it&#39;s new or not strictly part of the language... If you&#39;ll excuse the phrase, but I&#39;ve heard it a fair amount. I think that it&#39;s more around putting together the libraries and the support, the type of stuff that you described. &quot;I don&#39;t want to write a game engine, I just want to pull together a game&quot;, and that is another huge amount of work. I wouldn&#39;t be surprised if sooner or later we do see something emerge that is a pretty compelling approach. Maybe close to a cool typed API that would look really great for Go.

I just imagine that maybe it&#39;s gonna take a while before folks are happy to put the effort into building that sort of an engine binding to an existing engine in Go. It wouldn&#39;t really make any sense in my mind -- the differences between the languages in this space are so vast that I think you could spend a lot of time and realize that actually it&#39;s just too hard to read.

**Jon Calhoun:** \{32:16\} Yeah. I think one of the things that might also help there is that there&#39;s a lot of tools out there that are also very good at cross-platform game stuff. Steam has done a lot of work to make sure a lot of their games run on every OS, and as a result, you can kind of use their tools... So we&#39;re not really lacking. Whereas, like we talked about earlier, the rendering of graphical user interfaces across  systems - at least every approach I&#39;ve seen so far has had issues of some sort that people typically run into.

Basically, the really big UI that would start to lag if you had too much data or too much of anything in there was a big one that I saw a lot of companies complaining about. Because if you&#39;re doing an Airbnb and you have a  bunch of listings, it would start to not render correctly when you&#39;re swiping up, or it just wouldn&#39;t feel natural. So Go is  a good fit for that. But if you&#39;ve got games that are kind of working, I get that maybe it&#39;s not as big of an issue to get something in that space when there&#39;s already somebody who&#39;s solved that problem in another language, another way.

**Andy Williams:** Yeah, I guess that&#39;s a good point. I&#39;m not entirely sure how solved it is. Just from my experience with the games Christmas sale, I saw this huge list of great bargains and thought &quot;Oh, fantastic! I&#39;ll get a load of them.&quot; And then of course, only one in ten actually worked on the platform I was running on. So it may be technically solved, but there&#39;s clearly challenges there that mean it&#39;s not absolutely consistent.

This is a real problem actually with any API or platform that tries to do cross-platform; if there&#39;s really any roadblock to just rolling out across all of them, then you&#39;re gonna find people drop off really quite substantially. And if we&#39;re seeing new games getting released only for one platform out of three or four on a major system like steam, then I have to think -- I don&#39;t know the APIs, but I have to feel that there&#39;s probably something in there that makes it a real challenge. And if you&#39;re gonna claim cross-platform, it really needs to truly be cross-platform, without having to jump through hoops or do special things to make your code work.

**Jon Calhoun:** So given that that&#39;s the case, do  you think that anybody who&#39;s making a GUI library in Go needs to actually keep track of what languages things are being released in? If somebody&#39;s using Fyne and you find that a lot of your users are only actually releasing to MacOS, they&#39;re not actually releasing to Windows, Linux, Mac, or maybe they&#39;re choosing two of them - do you keep track of things like that, or try to keep an eye on that to sort of see if that&#39;s a sign that you&#39;re not doing as well as you could be in one operating system?

**Andy Williams:** That is probably something that we should do, actually, to have a better idea about where this is working for people and where it&#39;s not working so well. I imagined that we would get a lot of feedback from the community, which -- we have an awesome community, very supportive, very active, but the challenge here is that actually we&#39;re finding more people than I expected are using this in their workplace, to add a user interface to something that was maybe  a command line tool, or an ugly web form that they wanted to get rid of. So these types of projects are not really going out in the open, to be able to give us that visibility... So it&#39;s kind of lacking there a little bit.

We&#39;re trying to figure this out by publicizing the applications that are available. Anything that is open source, we&#39;re putting together a list of, and recommending that people check it out. But when it comes to &quot;What are you distributing for?&quot;, we&#39;re really trying to emphasize the cross-platform approach and say &quot;Look, just run the build for different target platforms.&quot; That&#39;s the only step. It doesn&#39;t make sense with the way that we&#39;re designing it to target only one platform. It may be that you only want to perform one upload or submit it to one store, but if the links are available on a website or on an open source repository, it&#39;s there for the taking; there&#39;s no additional complications to just rebuild it for the additional platforms... In theory.

**Johnny Boursiquot:** \{36:08\} I&#39;m curious about the design process, and the thinking that goes into deciding basically which direction the project should go in terms of this API footprint, what should it do, how should it do it, when should feature X, Y and Z come... I mean, you&#39;re at version 1.2.1 right now... Along those lines, are there design decisions that you made up to this point that you wish you could take back, or are there some things that you&#39;ve found out later on that basically you think could have been caught during the design phase?

I&#39;m asking because I don&#39;t know this world, and I don&#39;t know how different it is from the traditional software-engineering, practice and design, and all of the thinking and best practices that goes along with that.

**Andy Williams:** Sure, yeah. There&#39;s absolutely things that I would change with a year-and-a-half of hindsight, but not as much as maybe I&#39;d imagined we would. We&#39;re very careful about our design process, both from an interface design point of view, but also from an API design point of view. And the design of the API came before really a single line of implementation. The project started with an ambition to rethink how you could build graphical user interfaces across platform, and then came a broad strokes design outline as to how that API might function. Then we started implementing, initially with this other back-end component; so we didn&#39;t have to write the graphics drivers, but then eventually coached it all the way down.

So it is a very considerate approach... This is the way that I would consider any software engineering project if I was in a workplace. So when I started to think about this open source project, I wanted to make sure that we didn&#39;t compromise at all in that way. Obviously, there&#39;s other ways to build projects - get the code running, share it with some people and start building from there, but I felt that without a real design backing to this, it would struggle to keep its consistency over time. So when people ask for new features to be added, not only do we think &quot;How would that look as an API?&quot; and maybe even ask them how they&#39;d like to interact with it, but we also have to consider &quot;Well, is this something that makes sense for the majority of our users, and is it something that can make sense across the different target platforms that we want to support?&quot; So that we&#39;re not just dropping in a small feature for one platform, that then doesn&#39;t do what you&#39;d expect on other systems.

That process - I think it has served us very well. It does mean that sometimes features take a long time to develop... And you know, others are dropping quickly, but not always. So we have a roadmap that I&#39;ve put together probably initially, two years ago, and it evolves all the time; first of all, we wanted to get desktop apps working, and then we thought &quot;Okay, that&#39;s solid. Let&#39;s add some new widgets to it.&quot; Then it came time to look at mobile, so we targeted that for the 1.2 release last year.

Actually, as part of that release, we wanted to get data binding in there as well, because it&#39;s really simple to build a simple application, but then if you want to back a big data model into it, or connect more complex systems, display lots of items - even though that&#39;s pretty slick, there&#39;s still a lot of code to be written, and we thought &quot;If we&#39;re really gonna do this properly, we need a good data binding system.&quot; And we started designing it.

There was a lot of discussion, there was a bit of experimentation to see what could work, and it came close to release time and the mobile stuff was polishing out quite nicely. We had to say &quot;Look, actually, if we put this in right now, we don&#39;t think that we could commit to this being the API going forward forever.&quot; So we took that out of the release and invented a new 1.3.

\{40:04\} We were initially going to go directly to a big 2.0 drumroll, but we thought, &quot;No. Actually, to do this properly, we need to take more time. We need to engage with more external developers, so we&#39;re not just building as a development team what we think is right, but actually what makes sense for everybody else.&quot;

I&#39;m sure that the guys who are working on that could think it&#39;s been a lengthy process, because we&#39;ve been building that API now for over three months... That&#39;s quite a long time in any engineer&#39;s lifetime, I suppose. We&#39;re confident that we&#39;re gonna get it right, and actually the demos that are coming together now - they&#39;re blowing me away, actually, what a bit of time and consideration has created. It&#39;s really cool. So we&#39;re gonna continue to think really hard about all of these design elements.

The items that we would change if we could - they&#39;re very small details in the grand scheme of things, and maybe when 2.0 comes along, we can change some deprecated stuff and do a walkthrough about how people might update their code, but it shouldn&#39;t be a big deal... Long answer.

**Johnny Boursiquot:** No, it&#39;s great insight into the process. Yeah, it sounds like there&#39;s just as much agonizing over what the API should look like, what the developer experience should be that goes into any great API. So along those lines, you&#39;ve written a book, Hands on GUI Application Development in Go, and I&#39;m curious basically what the process, having worked with a lot of different GUI toolkits, from GTK to Qt, to any number of the ones you talk about in your book - I&#39;m curious what makes Go uniquely suited for Fyne, for the current project you&#39;re working on? What makes Go a good fit, or even what are some areas where it struggles compared to what you&#39;re familiar with in other frameworks, in other languages? Where does Go shine in this project?

**Andy Williams:** Yeah, wow... Thinking back to when we picked this as a language - I think part of it was how well-thought-out the language is, and the documentation that goes with it. If you&#39;re going to learn a new language and you just want to learn a new language, Go would be a fantastic option. It&#39;s so well put together. The documentation is there, the community support is there, and also the broader open source community and the way that all of this complex functionality is readily available for any developer, without having to know additional tooling. That was very compelling from a language design point of view.

But really, the process of writing the book, thinking about the challenges that have existed in graphical user interfaces through the ages, and looking at the challenges that the existing toolkits push on to their end users, I just couldn&#39;t help but notice that concurrency, memory management and building across multiple platforms - they were just like the three standout issues that really there was an opportunity to solve. And if you put a bullet list together like that and you say &quot;Which language is this a good fit for?&quot;, you don&#39;t have a very long list, and Go was really clearly at the top of it.

**Break:** \{43:17\}

**Jon Calhoun:** JavScript really shines at some of these aspects. The async model that JavScript tends to be, and the fact that it can react to events makes it great for graphical stuff... But I think that there&#39;s other areas where it doesn&#39;t quite shine the same way as Go does, which could make it a little bit different... And there&#39;s also the fact that people have done this in JavScript enough times that clearly -- I don&#39;t think that would have necessarily solved the problem to just do another JavScript library to do it.

**Andy Williams:** Absolutely. Honestly, when it came to pulling together the content for the book, it was commissioned, and one of the key items in what the book should contain was that actually, as well as being easy to build, it was important that these applications would be performant, as well as being easily built, that they would run really well... So for that reason, we thought &quot;Well, actually, let&#39;s not go with embedded browser engines and a JavScript stack.&quot; And that&#39;s not to say that it can&#39;t be done with JavScript, but if you were looking to compare a lot of technologies, I don&#39;t imagine there would be a huge number that really thought that performance was really top of the list, if that was the technology stack you were using. So I took the opportunity to say &quot;Well, in that case, let&#39;s not look at web technologies, let&#39;s just look at the way that people are doing this natively.&quot; I think it felt like a much more clean story about the history and future of graphical user interfaces... Of course, with Go.

**Jon Calhoun:** So if we&#39;re looking at different ways to build GUIs in Go, I guess first off, can we talk about just what options are there? You created Fyne, you mentioned andlabs UI, which is the one that compiles down to something that looks native to the OS... What other ones are out there, and can you talk a little bit about how they&#39;re going about rendering the UI? Does that make sense?

**Andy Williams:** Yeah, I can try. Honestly, the list is too long; I&#39;m going to miss people out if I try to pick through them. I hope this list doesn&#39;t show any of my particular prejudices, but it&#39;s somewhat inevitable. See, I mentioned andlabs; there are absolutely great projects that will bind to existing technologies as well. There&#39;s a couple of different ones for GDK and for Qt, so if that&#39;s something that you would like to play with, there&#39;s some really great stuff there. You might need a bigger amount of free space on your hard drive to be able to set those up, but they are established projects, with really substantial APIs.

If we&#39;re looking at -- things are a little bit different, I guess... A few years ago there was a couple of famous projects: Gx-ui and the Shiny project. Gx-ui, actually, I don&#39;t know a huge amount about, because that kind of went dormant a number of years ago... And although it was interesting maybe when I started researching the book, it seemed like it wasn&#39;t really going to pick up... So I looked at Shiny instead. This was a project that was put together by some people on the Go team, although I honestly can&#39;t remember their names right now... Apologies.

\{48:19\} This was, I guess, a really powerful technology demo of what could be done with Go. They implemented in very similar ways the OpenGL drivers in an abstraction on how you might paint using Go primitives... And in fact, that is used (I believe) for certain runtime configurations in the Go Mobile project to this day. It&#39;s a really solid project, it just doesn&#39;t really have much widget toolkit built on top of it. It sort of stopped where it was.

Then there is the [unintelligible 00:48:48.01] It&#39;s actually kind of contemporary with Fyne; it&#39;s been going for a couple of years or thereabout. But the approach that that project has taken is - although rendering a similar low-level API behind the scenes, they&#39;re using an immediate mode API, as opposed to the retain mode that Fyne has put together.

Basically, what that means is that each time the user interface wants to render a refresh, then the developer&#39;s code is going to  describe how the system should look at that point in time. That&#39;s really powerful for games development embedded systems... And actually, it&#39;s a  manner of putting together a graphics API that&#39;s gaining popularity in many areas. But the approach that I wanted to take with Fyne was to say &quot;Actually, this is gonna be minimal code for the end developer. We&#39;re gonna make a lot of assumptions on their behalf&quot;, and in that regard, Fyne is  a very opinionated toolkit. It looks a certain way, it behaves a certain way, and if you like it - brilliant; if no, it&#39;s maybe not gonna be for you... Whereas a toolkit that&#39;s got more flexibility could be very tempting to folks who wanna control every single aspect of how their application is going to work. I am sure that I have missed a couple off that list...

There&#39;s also bindings to other systems... The Nuclear project is quite interesting, and that contains Go bindings that are pretty easy to use. Then you&#39;ve got Wails and Walk for Windows-specific APIs. There are other platforms out there for solving particular problems, but I&#39;ve really only looked into the ones that we&#39;re aiming to make cross-platform graphical apps.

I hope I&#39;ve not missed anybody out there that thinks they&#39;re really happening in the space right now...

**Jon Calhoun:** I think everybody understands that it&#39;s hard to list everybody... So I&#39;ve only looked at Wails very briefly, but does it use Vue.js, or does it use something -- I wasn&#39;t sure what it was using to actually render stuff... Because it seemed like Fyne had this model of -- like you said, we kind of have an idea of what each component looks like, and you kind of use our predefined component type design... Andlabs was, like you said, trying to get everything native-looking... And it looked like Wails was more of like a wrapper around a JavScript-type view, that you had a little more customization around, but it wasn&#39;t necessarily native... Is that correct?

**Andy Williams:** That&#39;s my understanding. Actually, that&#39;s probably about the limit of my understanding of the project as well, because it falls in the category of hybrid or using web technologies. I haven&#39;t explored it anywhere near as much as the other ones that I spoke about there.

**Jon Calhoun:** Yeah. I know that this is a space that it would be fun to go build projects... Try to build a small project in each one of these... Because even like you&#39;d said, some of these are a little bit more involved, and I&#39;ve never dove into those... You said -- is it Q T? I don&#39;t know how you pronounce that one.

**Andy Williams:** Well, I think it&#39;s pronounced Qt.

**Jon Calhoun:** Qt? Okay. I was gonna say, I don&#39;t even know how to pronounce it, that&#39;s how limited my exposure is there... So I&#39;m just like &quot;Alright, I see people doing this, but I&#39;ve just never gotten there.&quot;

**Andy Williams:** \{52:13\} People tend to pick a camp, one that works for them for the reasons that they need at that time, and they just get passionate about it because it&#39;s solving the problems  that they want. I think that people who are picking up graphical app development now are looking to solve different problems.

One of the challenges I realized when exploring this is that very few of them have any web services integration; they don&#39;t really help you with persisting state between user sessions, or even different devices... And I&#39;m thinking if we can solve all of those things, you don&#39;t have to be on the web to take advantage of modern cloud-based technologies... So yeah, the right tool for building something is not necessarily the same tool as you want for communicating through the back-end systems.

So yeah, native apps I think have got an opportunity to perhaps gain a little bit more popularity if we really could make the cross-platform work well.

**Jon Calhoun:** I also liked -- you had mentioned that a  lot of people are using Fyne to do things like take something that&#39;s command line and make it a little bit more user-accessible... Which I find useful, because I find myself doing random, one-off tasks for my wife... My wife&#39;s a photographer, and there have been times where she&#39;s imported all the photos twice in a folder, so she&#39;s got a bunch that have the " 2" at the end... And as a programmer, you&#39;re like &quot;It takes no time at all to write something that just goes and deletes those all.&quot; She doesn&#39;t wanna go through it manually and delete them all; that&#39;s just really tedious for thousands of photos... So I see that and I&#39;m like &quot;Alright, this would be cool, to build a UI for her to work with, that she&#39;s not gonna mess things up. She can choose the right folder and do it.&quot;

I think there&#39;s a lot of small problems that could be solved that way. So if somebody wants to get into this, building something with a graphical user interface, do you have suggestions for them? Where would you suggest they start, what types of projects should they keep an eye out for?

**Johnny Boursiquot:** Before you answer, Andy... Jon, there is nothing wrong with a command line interface.

**Jon Calhoun:** No, there&#39;s nothing wrong with it. We&#39;re using it. But if I&#39;m trying to show my wife how to use it, there&#39;s a problem...

**Johnny Boursiquot:** [laughs] It sounds like you need to teach your wife how to use the command line, my friend.

**Jon Calhoun:** What happens if she says &quot;Honey, please come do this for me again&quot;, so I just do it every time?

**Johnny Boursiquot:** [laughs]

**Andy Williams:** I think how you get started depends on what you want to do. There&#39;s a lot to explore, and somebody who&#39;s curious should definitely check out the [Awesome List](https://awesome-go.com/). Go to the GUI section in Awesome Go and see what&#39;s there, and just try them all out, really.

Personally, I would think if somebody wants to get up and running with something graphical in Go, then they should absolutely head to the Fyne.io homepage and have a little read. We&#39;ve put together a tour that kind of follows the format that the Go Tour used, because it&#39;s just so easy to pick up really quickly... So we step people through what it means to put together a graphical application - how applications are linked to Windows, and how content is handled, and callbacks, that kind of thing.

So I&#39;m gonna absolutely just say that that&#39;s the way you should go... But given the graphical nature of it, I would also say head to YouTube, see what you can find. There&#39;s such a good selection of demos out there... And if you put a couple of key search terms in there, you&#39;re gonna see a huge variety of different things... And the code tutorials often come with them. That&#39;s sort of my biased angle on it...

Also, the GopherCon talks - I know this has come up a couple of times at GoLab, and hopefully you can discover more upcoming conferences as well... Although as an unusual use for Go, it&#39;s not something that gets a lot of air time on the bigger conferences, because it&#39;s not what people go there for.

\{56:04\} Yeah, so a bit of Go code up and running in your favorite editor and start typing out some keywords, and it&#39;s gonna discover these for you and suggest how you pull something together. A little application is really only gonna take a couple more lines of code than a command line application. Not everybody&#39;s really thinking quite so big as the Fyne team, who are currently reinventing the desktop by building the app from scratch in Go as well. There&#39;s a very big space for innovative and exciting applications in between those two, and I think it doesn&#39;t have to be difficult anymore. This is something that really is so much simpler in a modern, higher-level language.

**Johnny Boursiquot:** Don&#39;t sell yourself short, don&#39;t sell this project short... At Go conferences currently - and I can speak very confidently, at least for GopherCon - there are way more folks that are new to Go coming into the community than there are experienced developers. That&#39;s currently the state of affairs. We have way more newbies than any number of experienced developers... So a lot of folks are gonna be coming to the language and to the community through different avenues. The bigger the population, the more variation you&#39;re gonna have, and basically for people to take up the language.

So if somebody who&#39;s familiar with other GUI frameworks and they want to also learn Go, maybe Fyne is the gateway; that&#39;s the gateway by which they come into the Go community. So I think you&#39;re gonna see a lot more of this type of adoption through non-traditional avenues for new Go beginners.

**Andy Williams:** That&#39;s really good to hear, actually. I think you&#39;re right, there&#39;s so many more people coming into it now that we do need to think how you&#39;re bringing this to brand new folk, not to established Go developers... And I think that we&#39;ve been bearing that in mind, &quot;How do you make this obvious for the first-time developer?&quot;, of which a lot do fine and then apologize for the questions, and we say &quot;No, no, we want to know what you&#39;re struggling with, so we can make it better.&quot;

I think actually one of the unexpected challenges is that sometimes people come across the Fyne project and they want to learn Go and they&#39;re familiar with GUIs, and they&#39;re confused about why a thing that&#39;s really difficult for them isn&#39;t even present in the language or the toolkit... And there are a  couple of times where folks say &quot;No, no, you&#39;re missing this capability&quot;, and actually we have to say &quot;Well, we&#39;ve designed it slightly differently. That thing that you&#39;re familiar with and struggling with - just completely forget it.&quot;

So the preconceptions that people can have is actually harder work to help with than somebody coming in and going &quot;Oh man, I completely don&#39;t know this. What do I do?&quot;, because in that regard you point them at some documentation or a video... But if somebody knows an old system and they want to try and break free of it, that&#39;s a lot of built-in learning, and you don&#39;t necessarily know where it came from or why they picked up a previous system... So perhaps some reeducation to do, but also perhaps we do need to make something that looks more familiar, or adapt to familiar use cases, if that seems like  the right thing to do.

**Jon Calhoun:** Mat likes to do this segment, where we ask our guests what is their unpopular opinion... And it can be a tech opinion - I think he kind of leans towards that - but it doesn&#39;t have to be.

**Jingle:** \{59:32\} to \{59:48\}

**Jon Calhoun:** So Andy, what is your unpopular opinion that you&#39;d like to share?

**Andy Williams:** Well, so I thought about this, and I don&#39;t know how unpopular it is... I think that people might agree with it, but often don&#39;t... So I thought I would say that to me, a quality engineered approach is more important than the speed of development. This may be completely obvious to some folk, or it may be pretty challenging... And if you&#39;re building a project to a deadline, there&#39;s obviously gonna be a time pressure, but I&#39;d far more like to be involved in a project where they took their time, thought it through, and built something that was pretty solid... And maybe it was late or maybe it didn&#39;t have the functionality that was expected, but it&#39;s something to build on.

Looking project to project, it&#39;s perhaps a little bit difficult to think which is more important, but I look at the overall ecosystem of applications that we build our lives on now, and I think &quot;Goodness, if actually somebody had taken a little bit longer and thought this through, maybe it would work a little bit better, or maybe it could be easier maintained.&quot;

So although the Fyne project is about helping people get up and running with graphical apps really quickly, actually what&#39;s more important to us is helping people do it well, build a codebase that is easy to understand three, four, ten years down the road, rather than having to replatform or reinvent things.

I don&#39;t know if it&#39;s too out there or not, but it&#39;s something that I&#39;m surprised that not everybody agrees with, so... I thought I&#39;d just say it.

**Johnny Boursiquot:** I will see your unpopular opinion and raise you that level of quality of a project should match its urgency to get to market. [laughter]

**Andy Williams:** Yeah, I like that. It&#39;s a challenging thing sometimes though... It&#39;s obviously important to get somewhere fast, but if you get there fast and then have to back-track, or need a whole bunch more time to fix the things that got you there, it&#39;s difficult to see that it was worth the effort... [laughs] Anyway...

**Jon Calhoun:** A lot of this comes down to -- we&#39;ve talked about this a million times, but the size of your team, and everything else... Because if I&#39;m working on a project completely by myself, what I can get away with is drastically different, especially if I&#39;m not open-sourcing something... Because it&#39;s like, I&#39;m the only person that sees this, and if I need to rip this all out, nobody&#39;s gonna give me any grief for it, and I already understand how it all works, so it&#39;s not like I have to figure out &quot;What does this hodgepodge of code do?&quot; But I definitely agree that if you&#39;re working with teams on projects, especially like with you guys, releasing a graphical user interface, and having other people use it - that is a very different beast to tackle... And when you&#39;re doing that, you can&#39;t have people using it and then all of a sudden say &quot;All these APIs we had - we&#39;re ripping them all out. Good luck. If you wanna migrate to version two, you basically just throw all your code out.&quot; That&#39;s not a realistic migration strategy.

**Andy Williams:** No, that&#39;s painful. There&#39;s been a couple of famous situations  with that over the last few years... It&#39;s difficult to say that it could have been done better, but you just have to think &quot;Well, maybe a little bit less speed and a lot more thought in designing this could have been beneficial.&quot;

[01:03:14.15] It just occurred to me that the thing about team size is really interesting - it may be easy to not think about it so carefully when it&#39;s just you, but I find it to be helpful to think or actually do any new project out in the open, and think &quot;Would anybody who saw my code think I was doing a good job?&quot;, and imagine that the rest of the community is your code review peers. They&#39;re probably never gonna look at it, but I think it helps keep me honest, especially early days.

A project like this one - it had huge ambitions, and I had to start somewhere, and without the community as it started... It was helpful to think &quot;Well, if I was looking at this and had no idea, would it make sense?&quot; So yeah, I just pretended that the rest of the internet was reviewing my code.

**Johnny Boursiquot:** That&#39;s a lot of pressure to put on yourself... [laughter]

**Jon Calhoun:** I was gonna say, I think you could write perfect code, and the internet would still be brutal... But maybe I&#39;m too pessimistic, I don&#39;t know...

**Johnny Boursiquot:** It&#39;s true... [laughs] Somebody, somewhere is always gonna have an issue.

**Jon Calhoun:** Alright, Andrew, thank you for joining us. Everybody, thanks for joining us for Go Time. Hopefully, we&#39;ll get to cover the subject again in the future, and we&#39;ll cover some other unusual use cases for Go. If you have any ideas or suggestions for weird ways that people are using Go, definitely reach out and get in touch with us. We&#39;d love to hear about them.
